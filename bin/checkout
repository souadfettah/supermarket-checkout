#!/usr/bin/env ruby
# frozen_string_literal: true

# Make lib/ loadable when running from the repo
$LOAD_PATH.unshift File.expand_path("../lib", __dir__)

require "money"
require "product"
require "catalog"
require "checkout"
require "pricing_rules/bogo_rule"
require "pricing_rules/bulk_price_drop_rule"
require "pricing_rules/fractional_price_rule"
require "optparse"

USAGE = <<~TXT
  Usage:
    bin/checkout GR1 SR1 CF1           # compute the total for the given codes
    bin/checkout                        # start in interactive mode

  Options:
    -h, --help                          # show this help
    -r, --raw                           # print the raw total (BigDecimal) instead of £xx.xx

  Interactive mode:
    Enter one product code per line (e.g., GR1). Commands: total, basket, clear, help, quit/exit
TXT

options = { raw: false }

OptionParser.new do |opts|
  opts.on("-h", "--help") { puts USAGE; exit 0 }
  opts.on("-r", "--raw")  { options[:raw] = true }
end.parse!(ARGV)

# Define products & rules (same as tests/README)
products = [
  Product.new(code: "GR1", name: "Green tea",    price: "3.11"),
  Product.new(code: "SR1", name: "Strawberries", price: "5.00"),
  Product.new(code: "CF1", name: "Coffee",       price: "11.23")
]
catalog = Catalog.new(products)

rules = [
  BogoRule.new("GR1"),
  BulkPriceDropRule.new(code: "SR1", threshold: 3, new_price: "4.50"),
  FractionalPriceRule.new(code: "CF1", threshold: 3, numerator: 2, denominator: 3)
]

def print_total(co, raw:)
  if raw
    puts co.total.to_s("F")
  else
    puts co.total_formatted
  end
end

def print_basket(items)
  puts "Basket: #{items.join(', ')}"
end

# Mode 1: codes passed as arguments
if ARGV.any?
  co = Checkout.new(pricing_rules: rules, catalog: catalog)
  begin
    ARGV.each { |code| co.scan(code) }
    print_total(co, raw: options[:raw])
  rescue ArgumentError => e
    warn "Error: #{e.message}"
    exit 1
  end
  exit 0
end

# Mode 2: interactive
puts "Supermarket Checkout — interactive mode"
puts "Type 'help' for help. Products: GR1 (3.11), SR1 (5.00), CF1 (11.23)."
co = Checkout.new(pricing_rules: rules, catalog: catalog)
items = []

loop do
  print "> "
  line = $stdin.gets
  break if line.nil?
  cmd = line.strip

  case cmd.downcase
  when "", "help", "?","h"
    puts USAGE
  when "quit", "exit", "q"
    puts "Goodbye!"
    break
  when "total", "t"
    print_basket(items)
    print_total(co, raw: options[:raw])
  when "basket", "b"
    print_basket(items)
  when "clear", "c"
    co = Checkout.new(pricing_rules: rules, catalog: catalog)
    items.clear
    puts "Basket cleared."
  else
    # Treat as product code(s). Allow multiple tokens per line.
    tokens = cmd.split(/\s+/)
    begin
      tokens.each do |code|
        co.scan(code)
        items << code
        puts "Added: #{code}"
      end
    rescue ArgumentError => e
      warn "Error: #{e.message} — type 'basket' to see the basket or 'help' for help."
    end
  end
end
